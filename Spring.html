<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600553 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="392"/>

<div>
<span><div>Spring</div><div><br/></div><div>Spring是一个IOC(DI) AOP容器</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>Spring的bean配置</b></span></div><div style="margin-left: 40px;">1、基于XML文件</div><div style="margin-left: 40px;">2、基于注解</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>基于XML文件</b></span></div><div>创建一个Spring的配置文件</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">配置Bean形式：</span></div><div>    1、通过全类名的方式配置（反射）</div><div>        &lt;bean id=&quot;helloWorld&quot; class=&quot;cn.ccit.spring.hello.HelloWorld&quot;&gt;</div><div>            &lt;property name=&quot;user&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;</div><div>        &lt;/bean&gt;</div><div>    id：Bean的名称</div><div>        在IOC中必须唯一</div><div>        若id没指定，Spring自己将权限定性名作为Bean的名字</div><div>        id可指定多个名字，名字之间用逗号、分号或空格分隔</div><div><br/></div><div>    2、通过工厂方式（静态工厂方式&amp;实例工厂方式）</div><div>    </div><div>    3、FactoryBean</div><div>    </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">HelloWorld</span></div><div>1、创建SpringIOC容器</div><div>2、从IOC容器中获取Bean的实例</div><div>3、使用bean，调用方法</div><div><br/></div><div>    </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Spring的IOC容器</span></div><div>    SpringIOC容器在读取Bean配置创建Bean实例之前必须对它进行实例化</div><div>    两种IOC容器实现</div><div>    1、BeanFactory：IOC容器的基本实现</div><div>                    是Spring框架的基础设施，面向Spring本身</div><div>    </div><div>    2、ApplicationContext：提供了跟高级的特性，是BeanFactory的子接口</div><div>                    面向Spring框架的开发者，大多数情况可直接用</div><div>    二者配置文件是相同的</div><div>    </div><div>    Interface BeanFactory</div><div>            Interface ApplicationContext</div><div>            ---|Interface ConfigurableApplicationContext</div><div>                ---|ClassPathXmlApplicationContext    :从类路径下加载配置文件</div><div>                ---|FileSystemXmlApplicationContext  :从文件系统中加载配置文件</div><div>        </div><div>    ApplicationContext在初始化上下文时就实例化了所有的单例Bean</div><div>    </div><div>    WebApplicationContext是专门为WEB应用而准备的</div><div>    它允许从相对于WEB根目录的路径中完成初始化工作</div><div>    </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">从IOC容器中获取Bean</span></div><div>    BeanFactory中提供了getBean()方法</div><div>    直接调用BeanFactory实现类的getBean(id)方法即可</div><div>        一般方法的参数都为bean的id</div><div>    </div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">依赖注入的方式</span></div><div>    1、属性注入（最常用）</div><div>    通过setter方法注入Bean的属性值或依赖对象</div><div>    使用 &lt;property&gt; 元素</div><div>    name属性         Bean的属性名称</div><div>    value或&lt;value&gt;   子节点指定属性值</div><div>        &lt;bean id=&quot;helloWorld&quot; class=&quot;cn.ccit.spring.hello.HelloWorld&quot;&gt;</div><div>            &lt;property name=&quot;user&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;</div><div>        &lt;/bean&gt;</div><div>    </div><div>    2、构造器注入</div><div>    通过构造方法注入Bean的属性值或依赖对象，保证了Bean实例在实例化后就可以使用</div><div>    在 &lt;constructor-arg&gt; 元素里声明属性，没有name属性值</div><div>    构造方法有一个参数</div><div>        &lt;constructor-arg value=&quot;lisi&quot;&gt;&lt;/constructor-arg&gt;  </div><div>    构造方法有多个参数</div><div>        通过索引index匹配</div><div>        通过类型type匹配</div><div>        通过index和type精确定位</div><div>        &lt;bean id=&quot;car&quot; class=&quot;cn.ccit.spring.hello.Car&quot;&gt;</div><div>            &lt;constructor-arg value=&quot;qqq&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;</div><div>            &lt;constructor-arg value=&quot;zz&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt;</div><div>            &lt;constructor-arg value=&quot;120&quot; type=&quot;int&quot;&gt;&lt;/constructor-arg&gt;</div><div>        &lt;/bean&gt;</div><div>    </div><div>    3、工厂方法注入（用的少，不推荐）</div><div><br/></div><div>    注入属性值的细节</div><div>        &lt;value&gt;元素标签或value属性注入：&lt;value&gt;&lt;/value&gt;  value=&quot; &quot;</div><div>                可用字符串表示的值</div><div>                基本数据类型及封装类</div><div>                String</div><div>        若字面值中包含特殊字符可使用&lt;![CDATA[  ]]&gt;把字面值包裹起来</div><div>        &lt;constructor-arg&gt;</div><div>                &lt;value&gt;&lt;![CDATA[&lt;你好&gt;]]&gt;&lt;/value&gt;</div><div>        &lt;/constructor-arg&gt;</div><div>    </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">引用其他Bean</span></div><div>    要使Bean能够相互访问，就必须在Bean配置文件中指定对Bean的引用</div><div>    &lt;ref&gt;&lt;/ref&gt; 或 ref=&quot;  &quot;</div><div>    &lt;bean id=&quot;action&quot; class=&quot;cn.ccit.spring.ref.Action&quot;&gt;</div><div>        &lt;property name=&quot;service&quot; ref=&quot;service2&quot;&gt;&lt;/property&gt;</div><div>    &lt;/bean&gt;</div><div>    </div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">内部Bean</span></div><div>        在属性或构造器里包含的Bean声明，称为内部Bean</div><div>        包含在 &lt;property&gt; 或 &lt;constructor-arg&gt; 元素里</div><div>        不需要设置任何 id 或 name 属性</div><div>        内部 Bean 不能使用在任何其他地方</div><div>        &lt;bean name=&quot;service2&quot; class=&quot;cn.ccit.spring.ref.Service&quot;&gt;</div><div>            &lt;!-- 配置内置Bean --&gt;</div><div>            &lt;property name=&quot;dao&quot;&gt;</div><div>                &lt;bean class=&quot;cn.ccit.spring.ref.Dao&quot;&gt;</div><div>                    &lt;property name=&quot;dataSource&quot; value=&quot;c3p0&quot;&gt;&lt;/property&gt;                </div><div>                &lt;/bean&gt;</div><div>            &lt;/property&gt;</div><div>        &lt;/bean&gt;</div><div>    </div><div>    注入null值：&lt;null/&gt;</div><div>    </div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">设置级联属性</span></div><div>        &lt;!-- 设置级联属性 因为指向的dao没有属性注入 --&gt;</div><div>        &lt;property name=&quot;service.dao.dataSource&quot; value=&quot;c3p0&quot;&gt;&lt;/property&gt;</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">集合属性</span></div><div>    &lt;list&gt;  &lt;set&gt;  &lt;map&gt;  配置集合属性</div><div>    &lt;list&gt;、&lt;set&gt;</div><div>        1、需要指定 &lt;list&gt;、&lt;set&gt; 标签</div><div>        2、通过&lt;value&gt;指定简单的常量值</div><div>        3、通过&lt;ref&gt;指定对其他Bean的引用</div><div>        4、通过&lt;bean&gt;指定内置bean定义</div><div>        5、通过&lt;null/&gt;指定空元素</div><div>        </div><div>    &lt;map&gt;</div><div>        1、需要指定&lt;map&gt;标签</div><div>        2、&lt;map&gt;标签里可以使用多个&lt;entry&gt;作为子标签，每个条目包含一个键和一个值</div><div>        3、必须在&lt;key&gt;标签里定义键</div><div>        4、因为键和值的类型没有限制，所以可以自由地为它们指定&lt;value&gt;,&lt;ref&gt;,&lt;bean&gt;,&lt;null&gt;元素</div><div>        5、可以将Map的键和值作为&lt;entry&gt;的属性定义：简单的常量使用key和value来定义</div><div>                Bean引用通过key-ref和value-ref属性定义</div><div>        6、使用&lt;props&gt;定义 java.util.Properties，改标签使用多个&lt;prop&gt;作为子标签</div><div>                每个&lt;prop&gt;标签必须定义key属性</div><div><br/></div><div>    使用utility scheme定义集合</div><div>        需要导入util命名空间</div><div>        使用基本的集合标签定义集合时，不能将集合作为独立的Bean定义</div><div>        导致其他Bean无法引用该集合，所以无法再不同Bean之间共享集合</div><div>        可以使用util schema里的集合标签定义独立的集合Bean</div><div>        注意：必须在&lt;beans&gt;根元素里添加util schema定义</div><div>        &lt;util:list id=&quot;cars&quot;&gt;</div><div>            &lt;ref bean=&quot;car&quot;/&gt;</div><div>            &lt;ref bean=&quot;car2&quot;/&gt;</div><div>        &lt;/util:list&gt;</div><div>        &lt;bean id=&quot;user2&quot; class=&quot;cn.ccit.spring.hello.User&quot;&gt;</div><div>            &lt;property name=&quot;userName&quot; value=&quot;zurh&quot;&gt;&lt;/property&gt;</div><div>            &lt;!-- 引用外部声明的list --&gt;</div><div>            &lt;property name=&quot;cars&quot; ref=&quot;cars&quot;&gt;&lt;/property&gt;</div><div>            &lt;property name=&quot;wifeName&quot; value=&quot;8989&quot;&gt;&lt;/property&gt;</div><div>        &lt;/bean&gt;</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">p命名空间</span></div><div>    可通过&lt;bean&gt;元素属性的方式配置Bean的属性</div><div>        &lt;bean id=&quot;user5&quot; parent=&quot;user&quot; p:userName=&quot;mary&quot;&gt;&lt;/bean&gt;</div><div>        &lt;bean id=&quot;user5&quot; class=&quot;cn.ccit.spring.hello.User&quot; p:userName=&quot;mary&quot;&gt;&lt;/bean&gt;</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Bean自动装配</span></div><div>    在&lt;bean&gt;的autowire属性里指定自动装配的模式</div><div>    两个条件：</div><div>        byType：根据类型自动装配</div><div>        byName：根据名称自动装配</div><div>        construtor：通过构造器自动装配（当存在多个构造器是，这种方式会很复杂）不推荐使用</div><div>        </div><div>            &lt;bean id=&quot;service&quot; class=&quot;cn.ccit.spring.ref.Service&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</div><div>            &lt;bean id=&quot;action&quot; class=&quot;cn.ccit.spring.ref.Action&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;</div><div>        autowire属性会装配bean的所有属性，若只希望装配autowire属性就不够灵活了</div><div>        autowire要么根据类型自动装配，要么根据名称自动装配，二者不能兼得</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Bean之间的关系：继承</span></div><div>    1、spring允许继承bean的配置，子bean从父bean中继承配置，包括bean的属性配置</div><div>    2、子bean可以覆盖父bean继承过来的配置</div><div>    3、父bean作为模板，可以设置&lt;bean&gt;的abstract属性为true，这样Spring就不会实例化这个bean</div><div>    4、并不是&lt;bean&gt;元素里的所有属性都会被继承。如：autowire，abstract（抽象bean不能被继承）</div><div>    5、可以忽略父bean的class属性，让子bean指定自己的类，而共享相同的属性配置，但是abstract必设为true</div><div>    </div><div>        </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Bean之间的关系：依赖</span></div><div>    1、Spring允许用户通过depends-on属性设定Bean前置依赖的Bean，前置依赖的Bean会在本Bean实例化之前创建好</div><div>    2、如果前置依赖于多个Bean，则可通过逗号，空格或的方式配置Bean的名称</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Bean的作用域</span></div><div>    在Spring中可以在&lt;bean&gt;元素的scope属性里设置bean的作用域</div><div>    默认情况下，spring只为每个在IOC容器里声明的Bean创建唯一一个实例，整个IOC容器范围内都能共享该实例</div><div>    </div><div>    prototype: 原型的. 每次调用 getBean 方法都会返回一个新的 bean. 且在第一次调用 getBean 方法时才创建实例</div><div>    singleton: 单例的. 每次调用 getBean 方法都会返回同一个 bean. 且在 IOC 容器初始化时即创建 bean 的实例. 默认值</div><div>    request：每次http请求都会创建一个新的Bean，该作用域仅适于WebApplicationContext环境</div><div>    session：同一个http Session共享一个Bean，不同的http session使用不同的Bean。该作用域仅适于WebApplicationContext环境</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">使用外部属性文件</span></div><div>    Spring 提供了一个 PropertyPlaceholderConfigurer 的 BeanFactory 后置处理器,</div><div>    这个处理器允许用户将 Bean 配置的部分内容外移到属性文件中.</div><div>    Bean 配置文件里使用形式为 ${var} 的变量, PropertyPlaceholderConfigurer 从属性文件里加载属性</div><div>    并使用这些属性来替换变量.Spring 还允许在属性文件中使用 ${propName}，以实现属性之间的相互引用</div><div>    </div><div>    &lt;!-- 导入外部资源文件 --&gt;</div><div>    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</div><div>    </div><div>    &lt;!-- 配置数据源 --&gt;</div><div>    &lt;bean id=&quot;dataSource&quot; class=&quot;<a href="http://com.mchange.v2.c3p0.combopooleddatasource/">com.mchange.v2.c3p0.ComboPooledDataSource</a>&quot;&gt;</div><div>        &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;initialPoolSize&quot; value=&quot;${jdbc.initPoolSize}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;maxPoolSize&quot; value=&quot;${jdbc.maxPoolSize}&quot;&gt;&lt;/property&gt;</div><div>    &lt;/bean&gt;</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">SpEl</span></div><div>    Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。</div><div>    语法类似于 EL：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL</div><div>    SpEL 为 bean 的属性进行动态赋值提供了便利</div><div>    通过 SpEL 可以实现：</div><div>        1、通过 bean 的 id 对 bean 进行引用</div><div>        2、调用方法以及引用对象中的属性</div><div>        3、计算表达式的值</div><div>        4、正则表达式的匹配</div><div>        </div><div>    字面量的表示：</div><div>        整数：&lt;property name=&quot;count&quot; value=&quot;#{5}&quot;/&gt;</div><div>        小数：&lt;property name=&quot;frequency&quot; value=&quot;#{89.7}&quot;/&gt;</div><div>        科学计数法：&lt;property name=&quot;capacity&quot; value=&quot;#{1e4}&quot;/&gt;</div><div>        String可以使用单引号或者双引号作为字符串的定界符号：&lt;property name=“name” value=&quot;#{'Chuck'}&quot;/&gt; 或 &lt;property name='name' value='#{&quot;Chuck&quot;}'/&gt;</div><div>        Boolean：&lt;property name=&quot;enabled&quot; value=&quot;#{false}&quot;/&gt;</div><div>        </div><div>        &lt;bean id=&quot;car&quot; class=&quot;cn.ccit.spring.hello.Car&quot;&gt;</div><div>            &lt;!-- SpEl引用字面值 字符串类型 --&gt;</div><div>            &lt;property name=&quot;brand&quot; value=&quot;#{'品牌'}&quot;&gt;&lt;/property&gt;</div><div>            &lt;!-- SpEL引用类的静态属性 --&gt;</div><div>            &lt;property name=&quot;tyrePerimeter&quot; value=&quot;#{T(java.lang.Math).PI * 50}&quot;&gt;&lt;/property&gt;</div><div>        &lt;/bean&gt;</div><div>        &lt;bean id=&quot;person&quot; class=&quot;cn.ccit.spring.hello.Person&quot;&gt;</div><div>            &lt;!-- SpEL应用其他bean --&gt;</div><div>            &lt;property name=&quot;car&quot; value=&quot;#{car}&quot;&gt;&lt;/property&gt;</div><div>            &lt;!-- SpEl应用其他bean的属性 --&gt;</div><div>            &lt;property name=&quot;city&quot; value=&quot;#{address.city}&quot;&gt;&lt;/property&gt;</div><div>            &lt;!-- SpEl中使用运算符 --&gt;</div><div>            &lt;property name=&quot;info&quot; value=&quot;#{car.price &gt; 3000000 ? '金领' : '白领'}&quot;&gt;&lt;/property&gt;</div><div>        &lt;/bean&gt;</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">IOC容器中Bean的声明周期</span></div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">SpringIOC容器可以管理Bean的声明周期</span></div><div>    通过 init-method=&quot;init&quot;</div><div>         destroy-method=&quot;destroy&quot; 属性，为bean指定初始化和摧毁方法</div><div>    &lt;bean id=&quot;car&quot; class=&quot;cn.ccit.spring.beans.cycle.Car&quot;</div><div>        init-method=&quot;init&quot;</div><div>        destroy-method=&quot;destroy&quot;&gt;</div><div>        &lt;property name=&quot;brand&quot; value=&quot;audi&quot;&gt;&lt;/property&gt;</div><div>    &lt;/bean&gt;</div><div><br/></div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Bean的后置处理器</span></div><div>        需要实现BeanPostProcessor接口，并具体提供实现</div><div>        Object postProcessBeforeInitialization(Object bean,String beanName):init-method之前被调用</div><div>        Object postProcessAfterInitialization(Object bean,String beanName):init-method之后被调用</div><div>        bean：bean实例本身</div><div>        beanName：IOC容器配置 的bean名字</div><div>        返回值：是实际上返回给用户的那个bean</div><div>        注意：可以在以上两个方法中修改返回的bean，甚至返回一个新的bean</div><div>        配置bean的后置处理器，不需要配置id，IOC容器自动识别是一个BeanPostprocessor</div><div>    </div><div>        &lt;bean class=&quot;cn.ccit.spring.beans.cycle.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;</div><div>        </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">第二种方法</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">通过静态工厂方法创建Bean（第二种方式）</span></div><div>    调用静态工厂方法创建 Bean是将对象创建的过程封装到静态方法中.</div><div>    当客户端需要对象时, 只需要简单地调用静态方法, 而不同关心创建对象的细节</div><div>    bean配置</div><div>        1、class属=“拥有该工厂的方法的类”</div><div>        2、factory-method=“工厂方法的名称”</div><div>        3、使用&lt;constrctor-arg&gt;元素为该方法传递方法参数</div><div>    通过静态工厂方法来配置bean，不是静态工厂方法的实例，而是配置bean实例</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">通过调用实例工厂方法创建bean</span></div><div>    实例工厂方法: 将对象的创建过程封装到另外一个对象实例的方法里.</div><div>    当客户端需要请求对象时, 只需要简单的调用该实例方法而不需要关心对象的创建细节.</div><div>    bean配置</div><div>        1、factory-bean=“指定拥有工厂方法的bean”</div><div>        2、factory-method=“该工厂的名称”</div><div>        3、使用 construtor-arg 元素为工厂方法传递方法参数</div><div>    实例工厂的方法，需要创建工厂本身，再调用工厂的实例方法来返回bean的实例</div><div><br/></div><div>    &lt;!-- 通过工厂方法的方式来配置 bean --&gt;</div><div>    &lt;!-- 1. 通过静态工厂方法: 一个类中有一个静态方法, 可以返回一个类的实例(了解) --&gt;</div><div>    &lt;!-- 在 class 中指定静态工厂方法的全类名, 在 factory-method 中指定静态工厂方法的方法名 --&gt;</div><div>    &lt;bean id=&quot;dateFormat&quot; class=&quot;java.text.DateFormat&quot; factory-method=&quot;getDateInstance&quot;&gt;</div><div>        &lt;!-- 可以通过 constructor-arg 子节点为静态工厂方法指定参数 --&gt;</div><div>        &lt;constructor-arg value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;</div><div>    &lt;/bean&gt;</div><div>    </div><div>    &lt;!-- 2. 实例工厂方法: 先需要创建工厂对象, 再调用工厂的非静态方法返回实例(了解) --&gt;</div><div>    ①. 创建工厂对应的 bean</div><div>    &lt;bean id=&quot;simpleDateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt;</div><div>        &lt;constructor-arg value=&quot;yyyy-MM-dd hh:mm:ss&quot;&gt;&lt;/constructor-arg&gt;</div><div>    &lt;/bean&gt;</div><div>    </div><div>    ②. 有实例工厂方法来创建 bean 实例</div><div>    &lt;!-- factory-bean 指向工厂 bean, factory-method 指定工厂方法(了解) --&gt;</div><div>    &lt;bean id=&quot;datetime&quot; factory-bean=&quot;simpleDateFormat&quot; factory-method=&quot;parse&quot;&gt;</div><div>        &lt;!-- 通过 constructor-arg 执行调用工厂方法需要传入的参数 --&gt;</div><div>        &lt;constructor-arg value=&quot;1990-12-12 12:12:12&quot;&gt;&lt;/constructor-arg&gt;</div><div>    &lt;/bean&gt;</div><div>    </div><div>    </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">第三种方式：工厂bean FactoryBean</span></div><div>    工厂 Bean 跟普通Bean不同, 其返回的对象不是指定类的一个实例,</div><div><br/></div><div>    1、自定义的factorybean需要实现spring提供的FactoryBean接口</div><div>    2、class：指向FactoryBean的全类名</div><div>    3、property：配置FactoryBean的属性</div><div>    但实际上返回的是FactoryBean的getObject()方法返回的实例</div><div><br/></div><div>    &lt;!-- 配置通过 FactroyBean 的方式来创建 bean 的实例(了解) --&gt;</div><div>    &lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring.ref.UserBean&quot;&gt;&lt;/bean&gt;    </div><div>    </div><div>    </div><div><br/></div><div><b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">基于注解</b></div><div><br/></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">组件扫描</span></div><div>    Spring 能够从 classpath 下自动扫描, 侦测和实例化具有特定注解的组件.</div><div>    特定组件：</div><div>        @Component: 基本注解, 标识了一个受 Spring 管理的组件</div><div>        @Respository: 标识持久层组件</div><div>        @Service: 标识服务层(业务层)组件</div><div>        @Controller: 标识表现层组件</div><div>    对于扫描到的组件, Spring 有默认的命名策略: 使用非限定类名, 第一个字母小写. 也可以在注解中通过 value 属性值标识组件的名称</div><div><br/></div><div>    &lt;context:component-scan</div><div>        base-package=&quot;cn.ccit.spring.annotation&quot;</div><div>        resource-pattern=&quot;repository/*.class&quot;&gt;&lt;/context:component-scan&gt;</div><div>    base-package：指定IOC容器扫描的包</div><div>    resource-pattern：指定扫描的资源</div><div>    </div><div>    &lt;context:exclude-filter&gt; 子节点指定排除哪些指定表达式的组件</div><div>    &lt;context:include-filter&gt; 子节点指定包含哪些表达式的组件，该子节点需要use-default-filters=“false”</div><div><br/></div><div>    &lt;context:exclude-filter type=&quot;annotation&quot;</div><div>            expression=&quot;org.springframework.stereotype.Repository&quot;/&gt; 不包含</div><div><br/></div><div>    &lt;context:component-scan</div><div>        base-package=&quot;cn.ccit.spring.annotation&quot;</div><div>        use-default-filters=&quot;false&quot;&gt;</div><div>        &lt;context:include-filter type=&quot;assignable&quot;</div><div>            expression=&quot;cn.ccit.spring.annotation.repository.UserRepository&quot;/&gt;</div><div>    &lt;/context:component-scan&gt;</div><div><br/></div><div>    annotation：所有标注了XxxAnnotation的类（某个注解的类名）某目标类是否标注了某个注解进行过滤</div><div>    assinable：所有继承或扩展XxxService的类（类名或接口全名）某目标类是否继承或扩展某个特定类进行过滤</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">组件装配</span></div><div>    &lt;context:component-scan&gt; 元素还会自动注册 AutowiredAnnotationBeanPostProcessor 实例,</div><div>    该实例可以自动装配具有 @Autowired 和 @Resource 、@Inject注解的属性</div><div>    @Autowired注解 自动配置相应的bean实例</div><div>    </div><div>    字段自动配置</div><div>    @Autowired</div><div>    private UserService userService;</div><div>    </div><div>    方法自动配置</div><div>    @Autowired</div><div>    public void setUserService(UserService userService){</div><div>        this.userService = userService;</div><div>    }</div><div>    </div><div>    当接口多实现，存在多个兼容的bean时，有以下几个方法</div><div>    1、通过指定类的注解配置value属性，value属性指定bean的名称，名要和类型的默认类型名一致</div><div>        @Repository(&quot;userRepository&quot;)</div><div>        @Repository(value=&quot;userRepository&quot;)</div><div>    2、通过字段或方法注解的方式 或是 参数方式</div><div>        @Autowired</div><div>        @Qualifier(&quot;userRepositoryImpl&quot;)</div><div>        public void setUserRepository(/*@Qualifier(&quot;userRepositoryImpl&quot;) */UserRepository userRepository) {</div><div>            this.userRepository = userRepository;</div><div>        }</div><div>    @Authwired 注解也可以应用在数组类型的属性上, 此时 Spring 将会把所有匹配的 Bean 进行自动装配.</div><div>    @Authwired 注解也可以应用在集合属性上, 此时 Spring 读取该集合的类型信息, 然后自动装配所有与之兼容的 Bean.</div><div>    @Authwired 注解用在 java.util.Map 上时, 若该 Map 的键值为 String,</div><div>               那么 Spring 将自动装配与之 Map 值类型兼容的 Bean, 此时 Bean 的名称作为键值</div><div><br/></div><div>    Spring 还支持 @Resource 和 @Inject 注解，这两个注解和 @Autowired 注解的功用类似</div><div>    @Resource 注解要求提供一个 Bean 名称的属性，若该属性为空</div><div>              则自动采用标注处的变量或方法名作为 Bean 的名称</div><div>    @Inject   和 @Autowired 注解一样也是按类型匹配注入的 Bean</div><div>              但没有 reqired 属性</div><div>    建议使用 @Autowired 注解</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">泛型依赖注入</span></div><div>    Spring 4.x 中可以为子类注入子类对应的泛型类型的成员变量的引用</div><div><br/></div><div>    </div><div><b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">AOP：面向切面编程</b></div><div><br/></div><div><b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">基于注解：</b></div><div>    1、导入jar包</div><div>        <a href="http://com.springsource.org.aopalliance-1.0.0.jar/">com.springsource.org.aopalliance-1.0.0.jar</a></div><div>        <a href="http://com.springsource.org.aspectj.weaver-1.6.8.release.jar/">com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</a></div><div>        spring-aop-4.0.0.RELEASE.jar</div><div>        spring-aspects-4.3.9.RELEASE.jar</div><div>        </div><div>        commons-logging-1.1.1.jar</div><div>        spring-beans-4.0.0.RELEASE.jar</div><div>        spring-context-4.0.0.RELEASE.jar</div><div>        spring-core-4.0.0.RELEASE.jar</div><div>        spring-expression-4.0.0.RELEASE.jar</div><div>    </div><div>    2、在配置文件中加入AOP命名空间</div><div>    </div><div>    3、基于注解的方式</div><div><br/></div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">前置通知</span></div><div>        1、在配置文件中加入配置</div><div>            启用AspectJ的注解支持</div><div>            &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</div><div>        2、把横切关注点的代码抽象到切面的类中</div><div>            切面首先是一个IOC中的bean，即加入@Component</div><div>            切面还需要加入@Aspect 注解</div><div>        3、在类中声明各种通知</div><div>            声明一个方法</div><div>            在方法前加入@Before注解</div><div>        4、可以在通知方法中声明一个类型为JoinPoint的参数，然后就能访问连接细节。如方法名称和参数值</div><div>            joinPoint.getSignature().getName()</div><div>            joinPoint.getArgs()</div><div>            </div><div>        @Aspect</div><div>        @Component</div><div>        public class LogginAspect {</div><div>            //声明为前置通知 需要添加注解   执行什么方法 什么类下的所有方法</div><div>            @Before(&quot;execution(public int cn.ccit.spring.aop.ArithmeticCalculatorImpl.*(int,int))&quot;)</div><div>            public void beforeMethod(JoinPoint joinPoint){</div><div>                String methodName = joinPoint.getSignature().getName();</div><div>                List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());</div><div>                System.out.println(&quot;f方法：&quot; + methodName + &quot;begins with&quot; + args);</div><div>            }</div><div>        }</div><div>        </div><div>   <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"> AspectJ 支持 5 种类型的通知注解:</span></div><div>        @Before: 前置通知, 在方法执行之前执行</div><div>        @After: 后置通知, 在方法执行之后执行</div><div>        @AfterRunning: 返回通知, 在方法返回结果之后执行</div><div>        @AfterThrowing: 异常通知, 在方法抛出异常之后</div><div>        @Around: 环绕通知, 围绕着方法执行</div><div>        </div><div><span>    </span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">后置通知</span></div><div>        后置通知在连接点完成之后执行，即连接点返回结果或抛出异常时，后置通知记录了方法的终止</div><div>        一个切面可以包括一个或多个通知</div><div>        @After(&quot;execution(* cn.ccit.spring.aop.ArithmeticCalculatorImpl.*(int,int))&quot;)</div><div>        public void afterMethod(JoinPoint joinPoint){</div><div>            String methodName = joinPoint.getSignature().getName();</div><div>            System.out.println(&quot;f方法：&quot; + methodName + &quot;ends&quot;);</div><div>        }</div><div><br/></div><div>   <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"> 返回通知    </span>    </div><div>        无论连接点是正常返回还是抛出异常, 后置通知都会执行.</div><div>        如果只想在连接点返回的时候记录日志, 应使用返回通知代替后置通知.</div><div>        @AfterRunning: 返回通知, 在方法正常结束执行的代码，可以返回到方法的返回值的</div><div>        @AfterReturning(value=&quot;execution(* cn.ccit.spring.aop.ArithmeticCalculatorImpl.*(int,int))&quot;</div><div>            ,returning=&quot;result&quot;)    </div><div>            </div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">异常通知</span></div><div>        在目标方法出现异常时会执行的代码</div><div>        可以访问到异常对象，且可以指定在出现特定异常时在执行通知代码</div><div>        @AfterThrowing(value=&quot;execution(* cn.ccit.spring.aop.ArithmeticCalculatorImpl.*(..))&quot;</div><div>                ,throwing=&quot;e&quot;)</div><div>        public void afterThrowing(JoinPoint joinPoint,Exception e){</div><div>            String methodName = joinPoint.getSignature().getName();</div><div>            System.out.println(&quot;f方法：&quot; + methodName + &quot;occurs excetion&quot; + e);</div><div>        }    </div><div>        </div><div>   <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"> 环绕通知（最强大）</span></div><div>        环绕通知需要携带ProceedingJoinPoint类型的参数</div><div>        环绕通知类似于动态代理的全过程：ProceedingJoinPoint类型的参数可以决定是否执行目标方法</div><div>        且环绕通知必须有返回值，返回值即为目标方法的返回值</div><div>        @Around(&quot;execution(* cn.ccit.spring.aop.ArithmeticCalculatorImpl.*(..))&quot;)</div><div>        public Object aroundMethod(ProceedingJoinPoint pjd){</div><div>            Object result = null;</div><div>            String methodName = pjd.getSignature().getName();</div><div>            List&lt;Object&gt; args= Arrays.asList(pjd.getArgs());</div><div>            try {</div><div>                //前置通知</div><div>                System.out.println(&quot;前置通知：方法：&quot; + methodName + &quot; begins with&quot; + args);</div><div>                //执行目标方法</div><div>                result = pjd.proceed();//需要调用该方法来执行被代理方法  如果忘记这样做就会导致通知被执行了, 但目标方法没有被执行.</div><div>                //返回通知 可以返回方法值</div><div>                System.out.println(&quot;返回通知：方法：&quot; + methodName + &quot; ends&quot; + result);</div><div>                </div><div>            } catch (Throwable e) {</div><div>                //异常通知</div><div>                System.out.println(&quot;异常通知：the method&quot; + methodName + &quot; occurs excetion&quot; + e);</div><div>                e.printStackTrace();</div><div>            }</div><div>            //后置通知</div><div>            System.out.println(&quot;后置通知：方法：&quot; + methodName + &quot; ends&quot;);</div><div>            return result;</div><div>        }</div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">优先级</span></div><div>        若同一连接点上不值一个切面时，优先级是不确定的</div><div>        可以通过@Order(1) 注解指定</div><div>        实现 Ordered 接口, getOrder() 方法的返回值越小, 优先级越高.</div><div>            </div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">重用切入点定义</span></div><div>        通过 @Pointcut 注解将一个切入点声明成简单的方法. 切入点的方法体通常是空的</div><div>        切入点方法的访问控制符同时也控制着这个切入点的可见性</div><div>        </div><div>        @Pointcut(&quot;execution(public int cn.ccit.spring.aop.ArithmeticCalculatorImpl.*(int,int))&quot;)</div><div>        public void declareJoinPointException() {}</div><div>        </div><div>        @Before(&quot;declareJoinPointException()&quot;)</div><div>        public void beforeMethod(JoinPoint joinPoint){</div><div>            String methodName = joinPoint.getSignature().getName();</div><div>            List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());</div><div>            System.out.println(&quot;f方法：&quot; + methodName + &quot;begins with&quot; + args);</div><div>        }</div><div>            </div><div><b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">基于配置文件</b></div><div>    &lt;!-- 配置 bean --&gt;</div><div>    &lt;bean id=&quot;arithmeticCalculator&quot;</div><div>        class=&quot;com.atguigu.spring.aop.xml.ArithmeticCalculatorImpl&quot;&gt;&lt;/bean&gt;</div><div><br/></div><div>    &lt;!-- 配置切面的 bean. --&gt;</div><div>    &lt;bean id=&quot;loggingAspect&quot;</div><div>        class=&quot;com.atguigu.spring.aop.xml.LoggingAspect&quot;&gt;&lt;/bean&gt;</div><div><br/></div><div>    &lt;bean id=&quot;vlidationAspect&quot;</div><div>        class=&quot;com.atguigu.spring.aop.xml.VlidationAspect&quot;&gt;&lt;/bean&gt;</div><div><br/></div><div>    &lt;!-- 配置 AOP --&gt;</div><div>    &lt;aop:config&gt;</div><div>        &lt;!-- 配置切点表达式 --&gt;</div><div>        &lt;aop:pointcut expression=&quot;execution(* com.atguigu.spring.aop.xml.ArithmeticCalculator.*(int, int))&quot;</div><div>            id=&quot;pointcut&quot;/&gt;</div><div>        &lt;!-- 配置切面及通知 --&gt;</div><div>        &lt;aop:aspect ref=&quot;loggingAspect&quot; order=&quot;2&quot;&gt;</div><div>            &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</div><div>            &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</div><div>            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointcut&quot; throwing=&quot;e&quot;/&gt;</div><div>            &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointcut&quot; returning=&quot;result&quot;/&gt;</div><div>            &lt;!--  </div><div>            &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</div><div>            --&gt;</div><div>        &lt;/aop:aspect&gt;    </div><div>        &lt;aop:aspect ref=&quot;vlidationAspect&quot; order=&quot;1&quot;&gt;</div><div>            &lt;aop:before method=&quot;validateArgs&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</div><div>        &lt;/aop:aspect&gt;</div><div>    &lt;/aop:config&gt;</div><div>    基于 XML 的 AOP 配置不允许在切入点表达式中用名称引用其他切入点        </div><div>            </div><div>            </div><div><b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Spring的JDBC</b></div><div><br/></div><div>    配置：</div><div><br/></div><div>    &lt;!-- 注解自动配置 --&gt;</div><div>    &lt;context:component-scan base-package=&quot;cn.ccit.spring&quot;&gt;&lt;/context:component-scan&gt;</div><div><br/></div><div>    &lt;!-- 导入资源文件 --&gt;</div><div>    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</div><div>    </div><div>    &lt;!-- 配置c3p0数据源 --&gt;</div><div>    &lt;bean id=&quot;dataSource&quot; class=&quot;<a href="http://com.mchange.v2.c3p0.combopooleddatasource/">com.mchange.v2.c3p0.ComboPooledDataSource</a>&quot;&gt;</div><div>        &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;initialPoolSize&quot; value=&quot;${jdbc.initPoolSize}&quot;&gt;&lt;/property&gt;</div><div>        &lt;property name=&quot;maxPoolSize&quot; value=&quot;${jdbc.maxPoolSize}&quot;&gt;&lt;/property&gt;</div><div>    </div><div>    &lt;/bean&gt;</div><div>    </div><div>    </div><div>    &lt;!-- 配置spring的jdbcTemplate --&gt;</div><div>    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</div><div>        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</div><div>    &lt;/bean&gt;</div><div>    </div><div>    &lt;!-- 配置NamedParameterJdbcTemplate,该对象可以使用具名参数，若没有无参构造器，所以必须为其构造器指定参数 --&gt;</div><div>    &lt;bean id=&quot;namedParameterJdbcTemplate&quot;</div><div>        class=&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;&gt;</div><div>        &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;</div><div>    &lt;/bean&gt;</div><div>            </div><div>    测试类：</div><div>    public class JDBCTest {</div><div>        private ApplicationContext ctx = null;</div><div>        private JdbcTemplate jdbcTemplate;</div><div>        private EmployeeDao employeeDao;</div><div>        private UserDao userDao;</div><div>        private NamedParameterJdbcTemplate namedParameterJdbcTemplate;</div><div>        </div><div>        //初始化代码块</div><div>        {</div><div>            ctx = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;);</div><div>            jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);</div><div>            employeeDao = (EmployeeDao)ctx.getBean(&quot;employeeDao&quot;);</div><div>            userDao = ctx.getBean(UserDao.class); //唯一bean</div><div>            namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate.class);</div><div>        }</div><div>        </div><div>        /*</div><div>         * 执行insert update delete</div><div>         */</div><div>        @Test</div><div>        public void testUpdate(){</div><div>            String sql = &quot;update user set name=? where id=?&quot;;</div><div>            jdbcTemplate.update(sql,&quot;zrh&quot;,2);</div><div>        }</div><div>        /*</div><div>         * 批量更新数据</div><div>         *  执行批量更新: 批量的 INSERT, UPDATE, DELETE</div><div>         * 最后一个参数是 Object[] 的 List 类型: 因为修改一条记录需要一个 Object 的数组, 那么多条不就需要多个 Object 的数组吗</div><div>         */</div><div>        @Test</div><div>        public void testBatchUpdate(){</div><div>            String sql = &quot;insert into user values(?,?)&quot;;</div><div>            List&lt;Object[]&gt; list = new ArrayList&lt;&gt;(); //集合里放数组</div><div>            list.add(new Object[]{&quot;77&quot;,&quot;nifhs&quot;});</div><div>            list.add(new Object[]{&quot;78&quot;,&quot;kkk&quot;});</div><div>            list.add(new Object[]{&quot;79&quot;,&quot;lll&quot;});</div><div>            jdbcTemplate.batchUpdate(sql,list);</div><div>        }</div><div>        </div><div>        /*</div><div>         * 查询单行</div><div>         * 从数据库中获取一条记录, 实际得到对应的一个对象</div><div>         * 注意不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object... args) 方法!</div><div>         * 而需要调用 queryForObject(String sql, RowMapper&lt;Employee&gt; rowMapper, Object... args)</div><div>         * 1. 其中的 RowMapper 指定如何去映射结果集的行, 常用的实现类为 BeanPropertyRowMapper</div><div>         * 2. 使用 SQL 中列的别名完成列名和类的属性名的映射. 例如 last_name lastName</div><div>         * 3. 不支持级联属性. JdbcTemplate 到底是一个 JDBC 的小工具, 而不是 ORM 框架</div><div>         */</div><div>        @Test</div><div>        public void testQueryForObject(){</div><div>            String sql = &quot;select name from user where id=?&quot;;</div><div>            RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(User.class);</div><div>            User user = jdbcTemplate.queryForObject(sql, rowMapper,1);</div><div>            System.out.println(user);</div><div>        }</div><div>        </div><div>        /*</div><div>         * 查询多行</div><div>         * 查到实体类的集合</div><div>         * 注意调用的不是queryForList方法</div><div>         */</div><div>        @Test</div><div>        public void testQueryForList(){</div><div>            String sql = &quot;select * from user where id&gt;?&quot;;</div><div>            RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(User.class);</div><div>            List&lt;User&gt; users = jdbcTemplate.query(sql, rowMapper,2);</div><div>            System.out.println(users);</div><div>        }</div><div>        </div><div>        /*</div><div>         * 单值查询</div><div>         * 获取单个列的值，或做统计查询</div><div>         * 使用 queryForObject(String sql, Class&lt;Long&gt; requiredType)</div><div>         */</div><div>        @Test</div><div>        public void testQueryForObject2(){</div><div>            String sql = &quot;select count(id) from user&quot;;</div><div>            Integer count = jdbcTemplate.queryForObject(sql, Integer.class);</div><div>            System.out.println(count);</div><div>        }</div><div>        </div><div>        @Test</div><div>        public void testUserDao(){</div><div>            System.out.println(userDao.get(1));</div><div>        }</div><div>        @Test</div><div>        public void testEmployeeDao(){</div><div>            System.out.println(employeeDao.get(1));</div><div>        }</div><div>        /*</div><div>         * 使用具名参数</div><div>         * Map</div><div>            可以为参数起名字.</div><div>            1. 好处: 若有多个参数, 则不用再去对应位置, 直接对应参数名, 便于维护</div><div>            2. 缺点: 较为麻烦.</div><div>         */</div><div>        @Test</div><div>        public void testNamedParameterJdbcTemplate(){</div><div>            String sql = &quot;insert into user values(:id,:name)&quot;;</div><div>            Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;();</div><div>            paramMap.put(&quot;id&quot;, &quot;6&quot;);</div><div>            paramMap.put(&quot;name&quot;, &quot;bjy&quot;);</div><div>            namedParameterJdbcTemplate.update(sql, paramMap);</div><div>        }</div><div>        /*</div><div>         * 使用具名参数</div><div>         * SqlParameterSource</div><div>            使用具名参数时, 可以使用 update(String sql, SqlParameterSource paramSource) 方法进行更新操作</div><div>              1. SQL 语句中的参数名和类的属性一致!</div><div>             2. 使用 SqlParameterSource 的 BeanPropertySqlParameterSource 实现类作为参数.</div><div>         */</div><div>        @Test</div><div>        public void testNamedParameterJdbcTemplate2(){</div><div>            String sql = &quot;insert into employee values(:id,:lastName,:email,:dpetId)&quot;;</div><div>            Employee employee = new Employee();</div><div>            employee.setEmail(&quot;<a href="mailto:456@qq.com">456@qq.com</a>&quot;);</div><div>            employee.setDpetId(2);</div><div>            employee.setId(2);</div><div>            employee.setLastName(&quot;li&quot;);</div><div>            </div><div>            SqlParameterSource paramSource = new BeanPropertySqlParameterSource(employee);</div><div>            namedParameterJdbcTemplate.update(sql, paramSource);</div><div>        }</div><div>        @Test</div><div>        public void testDataSource() throws SQLException{</div><div>            DataSource dataSource = (DataSource)ctx.getBean(&quot;dataSource&quot;);</div><div>            </div><div>            System.out.println(dataSource.getConnection());</div><div>        }</div><div>    }</div><div>    </div><div>    JdbcDaoSource：</div><div>    /**</div><div>     * 不推荐使用JdbcDaoSupport，而推荐直接使用JdbcTemplate作为Dao类的成员变量</div><div>     */</div><div>    @Repository</div><div>    public class UserDao extends JdbcDaoSupport{</div><div><br/></div><div>        @Autowired</div><div>        public void setDataSource2(DataSource dataSource){</div><div>            setDataSource(dataSource);</div><div>        }</div><div>        </div><div>        public User get(Integer id){</div><div>            String sql = &quot;select * from user where id = ?&quot;;</div><div>            RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(User.class);</div><div>            return getJdbcTemplate().queryForObject(sql, rowMapper,1);</div><div>        }</div><div>    }</div><div>    </div><div><b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Spring的事务</b></div><div><br/></div><div><br/></div><div><b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    基于注解的配置</b></div><div>        使用@Thansactional 注解</div><div>        </div><div>        </div><div>        &lt;!-- 配置事务管理器 --&gt;</div><div>        &lt;bean id=&quot;transactionManager&quot;</div><div>            class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</div><div>            &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;</div><div>        &lt;/bean&gt;</div><div>            </div><div>        </div><div>        &lt;!-- 启用事务注解 --&gt;</div><div>        &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</div><div>        </div><div>        </div><div>        添加事务注解</div><div>            1.使用 propagation 指定事务的传播行为, 即当前的事务方法被另外一个事务方法调用时</div><div>            如何使用事务, 默认取值为 REQUIRED, 即使用调用方法的事务</div><div>            REQUIRES_NEW: 事务自己的事务, 调用的事务方法的事务被挂起.</div><div>            2.使用 isolation 指定事务的隔离级别, 最常用的取值为 READ_COMMITTED</div><div>            3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚. 也可以通过对应的</div><div>            属性进行设置. 通常情况下去默认值即可.</div><div>            4.使用 readOnly 指定事务是否为只读. 表示这个事务只读取数据但不更新数据,</div><div>            这样可以帮助数据库引擎优化事务. 若真的事一个只读取数据库值的方法, 应设置 readOnly=true</div><div>            5.使用 timeout 指定强制回滚之前事务可以占用的时间.  </div><div>    //    @Transactional(propagation=Propagation.REQUIRES_NEW,</div><div>    //            isolation=Isolation.READ_COMMITTED,</div><div>    //            noRollbackFor={UserAccountException.class}) //对那些异常进行回滚 默认的通常不配置</div><div>        @Transactional(propagation=Propagation.REQUIRES_NEW,</div><div>                isolation=Isolation.READ_COMMITTED,</div><div>                readOnly=false,</div><div>                timeout=3)</div><div>        </div><div>            </div><div><b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    基于配置文件xml</b></div><div>        &lt;!-- 1、配置事务管理器 --&gt;</div><div>        &lt;bean id=&quot;transactionManager&quot;</div><div>            class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</div><div>            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</div><div>        &lt;/bean&gt;</div><div>        </div><div>        &lt;!-- 2、 配置事务属性 --&gt;</div><div>        &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</div><div>            &lt;tx:attributes&gt;</div><div>                &lt;!-- 根据方法名指定事务的属性 --&gt;</div><div>                &lt;tx:method name=&quot;purchase&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;</div><div>                &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</div><div>                &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;</div><div>                &lt;tx:method name=&quot;*&quot;/&gt;</div><div>            &lt;/tx:attributes&gt;</div><div>        &lt;/tx:advice&gt;</div><div>        </div><div>        &lt;!-- 3. 配置事务切入点, 以及把事务切入点和事务属性关联起来 --&gt;</div><div>        &lt;aop:config&gt;</div><div>            &lt;aop:pointcut expression=&quot;execution(* com.atguigu.spring.tx.xml.service.*.*(..))&quot;</div><div>                id=&quot;txPointCut&quot;/&gt;</div><div>            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;    </div><div>        &lt;/aop:config&gt;</div><div>    </div><div>            </div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">事务的传播性为</span></div><div>        REQUIRED：默认。如果有事务在运行，当前方法就在这个事务内运行，否则就启动一个新的事务并在自己的事务内运行</div><div>        REQUIRED_NEW：当前方法必须启动新事务，并在它自己的事务内运行，如果有事务正运行，应将它挂起</div><div>    </div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">事务的隔离级别</span></div><div>        DEFAULT：使用底层数据库的默认事务隔离级别</div><div>        READ_UNCOMMITED：不能解决任何问题</div><div>        READ_COMMITED：解决了脏读.  不可重复读和幻读仍会出现</div><div>        REPEATABLE_READ：解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决</div><div>        SERIALIZABLE：都可以避免 需要加锁</div><div>    </div><div>    </div><div>        Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</div><div>        Mysql 支持 4 中事务隔离级别.默认REPEATABLE_READ select @@tx_isolation;</div><div>            </div><div>            </div><div>            </div><div>            </div><div>            </div><div>            </div><div>            </div></span>
</div></body></html> 